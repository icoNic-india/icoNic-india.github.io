<p>Malware Series #1: From Notepad to the Kernel ‚Äî Understanding User Mode vs Kernel Mode in Windows</p>

<p>When you open Notepad, it feels simple. But under the hood, even this basic Windows application walks a complex path from user mode to kernel mode. Understanding that path is essential for malware analysts, because malicious software follows the same journey ‚Äî and often tries to manipulate it.</p>

<p>In this article, we‚Äôll use Process Monitor (Procmon) and WinDbg to trace Notepad‚Äôs behavior. Along the way, we‚Äôll see how Windows transitions between user and kernel space, and why this matters in the world of malware analysis.</p>

<ol>
  <li>Process Startup: Loading the Foundations</li>
</ol>

<p>The first thing Procmon reveals is that when Notepad starts, it pulls in a familiar set of DLLs:</p>

<p>Procmon trace showing Notepad loading ntdll.dll, kernel32.dll, and KernelBase.dll.</p>

<p>The Essential DLLs</p>

<p>ntdll.dll ‚Äì The last stop in user mode before entering the kernel. It contains system call stubs that eventually trigger the syscall instruction.</p>

<p>kernel32.dll ‚Äì A higher-level wrapper that exposes the Windows API developers use every day ‚Äî memory, file I/O, threading.</p>

<p>KernelBase.dll ‚Äì A core library that took over much of kernel32.dll‚Äôs responsibilities starting with Windows 7.</p>

<p>Every Windows process ‚Äî whether it‚Äôs Notepad or a sophisticated malware sample ‚Äî relies on these libraries. They are the foundations of Windows user mode.</p>

<p>üí° Malware Analyst‚Äôs Corner
Attackers often hook or patch functions inside kernel32.dll or KernelBase.dll to intercept API calls. By knowing that every process loads these DLLs, analysts can focus their attention on these hot spots when looking for injected or tampered code.</p>

<ol>
  <li>The System Call Transition</li>
</ol>

<p>Once the DLLs are in place, Notepad doesn‚Äôt directly manipulate the kernel. Instead, its API calls flow into ntdll.dll, which issues the actual syscall instruction.</p>

<p>WinDbg showing NtCreateFile ending with syscall, the CPU instruction that transitions execution from user mode to kernel mode.</p>

<p>At this precise point, execution leaves user space and enters kernel space. The CPU switches context, moving from Ring 3 (user mode) to Ring 0 (kernel mode), and Windows kernel components like ntoskrnl.exe take over.</p>

<p>This boundary ‚Äî invisible to most users ‚Äî is one of the most important in the operating system. It defines privilege separation.</p>

<p>üí° Malware Analyst‚Äôs Corner
Many exploits aim at this transition. If malware can manipulate how syscalls are issued (e.g., via direct system call invocation or syscall stubs), it can sometimes bypass user-mode security hooks like EDR agents that rely on API monitoring.</p>

<ol>
  <li>Kernel Execution: Inside the OS Core</li>
</ol>

<p>So what happens once the syscall lands in kernel mode? Procmon‚Äôs stack traces tell the story:</p>

<p>Procmon call stack showing the transition from ntdll.dll in user mode into ntoskrnl.exe and FLTMGR.SYS in kernel mode.</p>

<p>Here we can see:</p>

<p>ntdll.dll as the last user-mode participant.</p>

<p>ntoskrnl.exe ‚Äî the Windows kernel itself ‚Äî processing the request.</p>

<p>FLTMGR.SYS ‚Äî the filter manager that routes file operations through installed drivers (antivirus, encryption, backup tools).</p>

<p>Even something as mundane as closing a file involves this chain of events.</p>

<p>üí° Malware Analyst‚Äôs Corner
Rootkits often load as kernel-mode drivers, hooking into the file system filter chain (FLTMGR.SYS). By doing so, they can hide files, processes, or registry keys from security tools. Analysts must carefully study these kernel stack traces to spot unexpected or unsigned drivers.</p>

<ol>
  <li>Putting It All Together</li>
</ol>

<p>Here‚Äôs a simplified flowchart of the path a Notepad request takes ‚Äî from user mode, through the syscall boundary, into kernel execution:</p>

<p>flowchart TD
    A[Notepad.exe<br />(User Mode App)] ‚Äì&gt; B[kernel32.dll / KernelBase.dll<br />(Windows API)]
    B ‚Äì&gt; C[ntdll.dll<br />(Syscall Stub)]
    C ‚Äì&gt; D[‚Äúsyscall instruction<br />(User ‚Üí Kernel Transition)‚Äù]
    D ‚Äì&gt; E[ntoskrnl.exe<br />(Windows Kernel)]
    E ‚Äì&gt; F[Drivers e.g., FLTMGR.SYS<br />(File System / AV / Filters)]
    F ‚Äì&gt; G[Hardware / Disk I/O]</p>

<p>This flow illustrates the layered design of Windows: applications talk to libraries, libraries issue syscalls, syscalls transition into kernel mode, and the kernel hands off to drivers and hardware.</p>

<p>üìå Takeaway</p>

<p>Even Notepad ‚Äî one of the simplest Windows applications ‚Äî reveals the deep architecture of Windows. From DLL loading, through syscalls, into the kernel, it highlights the critical boundary between user mode and kernel mode.</p>

<p>For malware analysts, that boundary is both a line of defense and a frequent target for attackers. Understanding how this journey works is essential for detecting, dissecting, and defending against malicious activity.</p>

<p>‚ö° In the next part of this series, we‚Äôll dive into how malware abuses API hooking in ntdll.dll to hide its activity.</p>
