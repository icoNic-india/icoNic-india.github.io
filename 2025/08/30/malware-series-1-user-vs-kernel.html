<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Malware Series #1: From Notepad to the Kernel — Understanding User Mode vs Kernel Mode in Windows | My Blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Malware Series #1: From Notepad to the Kernel — Understanding User Mode vs Kernel Mode in Windows" />
<meta name="author" content="icoNic" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="🛡️ Malware Series #1: From Notepad to the Kernel Understanding User Mode vs Kernel Mode in Windows" />
<meta property="og:description" content="🛡️ Malware Series #1: From Notepad to the Kernel Understanding User Mode vs Kernel Mode in Windows" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-30T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Malware Series #1: From Notepad to the Kernel — Understanding User Mode vs Kernel Mode in Windows" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"icoNic"},"dateModified":"2025-08-30T00:00:00+00:00","datePublished":"2025-08-30T00:00:00+00:00","description":"🛡️ Malware Series #1: From Notepad to the Kernel Understanding User Mode vs Kernel Mode in Windows","headline":"Malware Series #1: From Notepad to the Kernel — Understanding User Mode vs Kernel Mode in Windows","mainEntityOfPage":{"@type":"WebPage","@id":"/2025/08/30/malware-series-1-user-vs-kernel.html"},"url":"/2025/08/30/malware-series-1-user-vs-kernel.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>My Blog</h1>
        </a>
        <h2>Learning malware dev and sharing my journey</h2>

        <section id="downloads">
          
          <a href="" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>30 August 2025</small>
<h1>Malware Series #1: From Notepad to the Kernel — Understanding User Mode vs Kernel Mode in Windows</h1>

<p class="view">by icoNic</p>

<h1 id="️-malware-series-1-from-notepad-to-the-kernel">🛡️ Malware Series #1: From Notepad to the Kernel</h1>
<h3 id="understanding-user-mode-vs-kernel-mode-in-windows">Understanding User Mode vs Kernel Mode in Windows</h3>

<p>When you open <strong>Notepad</strong>, it feels simple. But under the hood, even this basic Windows application walks a complex path from <strong>user mode to kernel mode</strong>.</p>

<p>Understanding that path is essential for malware analysts, because malicious software follows the same journey — and often tries to manipulate it.</p>

<p>In this article, we’ll use <strong>Process Monitor (Procmon)</strong> and <strong>WinDbg</strong> to trace Notepad’s behavior. Along the way, we’ll see how Windows transitions between user and kernel space, and why this matters in the world of malware analysis.</p>

<hr />

<h2 id="-step-1-process-startup--loading-the-foundations">🔹 Step 1: Process Startup — Loading the Foundations</h2>

<p>The first thing Procmon reveals is that when Notepad starts, it pulls in a familiar set of DLLs:</p>

<p><img src="/assets/images/notepad-dll-load.png" alt="Notepad DLL load — annotated" /><br />
<em>Procmon trace showing Notepad loading <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, and <code class="language-plaintext highlighter-rouge">KernelBase.dll</code>.</em></p>

<h3 id="-the-essential-dlls">🧩 The Essential DLLs</h3>
<ul>
  <li><strong>ntdll.dll</strong> → The last stop in user mode before entering the kernel. It contains system call stubs that eventually trigger the <code class="language-plaintext highlighter-rouge">syscall</code> instruction.</li>
  <li><strong>kernel32.dll</strong> → A higher-level wrapper exposing the Windows API developers use every day — memory, file I/O, threading.</li>
  <li><strong>KernelBase.dll</strong> → A core library that took over much of <code class="language-plaintext highlighter-rouge">kernel32.dll</code>’s responsibilities starting with Windows 7.</li>
</ul>

<p>Every Windows process — whether it’s Notepad or a sophisticated malware sample — relies on these libraries. They are the <em>foundations</em> of Windows user mode.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Attackers often <strong>hook or patch functions</strong> inside <code class="language-plaintext highlighter-rouge">kernel32.dll</code> or <code class="language-plaintext highlighter-rouge">KernelBase.dll</code> to intercept API calls. Since every process loads these DLLs, analysts should check them first for injected or tampered code.</p>
</blockquote>

<hr />

<h2 id="-step-2-the-system-call-transition">🔹 Step 2: The System Call Transition</h2>

<p>Once the DLLs are in place, Notepad doesn’t directly manipulate the kernel. Instead, its API calls flow into <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, which issues the actual <strong><code class="language-plaintext highlighter-rouge">syscall</code> instruction</strong>.</p>

<p><img src="/assets/images/syscall-transition.png" alt="Syscall boundary — annotated" /><br />
<em>WinDbg showing <code class="language-plaintext highlighter-rouge">NtCreateFile</code> ending with <code class="language-plaintext highlighter-rouge">syscall</code>, the CPU instruction that transitions execution from user mode to kernel mode.</em></p>

<p>At this precise point, execution leaves user space and enters kernel space:</p>
<ul>
  <li>The CPU switches context from <strong>Ring 3 (user mode)</strong> → <strong>Ring 0 (kernel mode)</strong>.</li>
  <li>The Windows kernel (<code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>) takes over to process the request.</li>
</ul>

<p>This invisible boundary is one of the most important in the OS. It defines <strong>privilege separation</strong>.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Many exploits target this syscall boundary. If malware can manipulate syscalls directly (bypassing user-mode APIs), it may <strong>evade EDR hooks</strong> that monitor high-level API calls.</p>
</blockquote>

<hr />

<h2 id="-step-3-kernel-execution--inside-the-os-core">🔹 Step 3: Kernel Execution — Inside the OS Core</h2>

<p>What happens once the syscall lands in kernel mode?<br />
Procmon’s stack traces show the journey clearly:</p>

<p><img src="/assets/images/procmon-kernel-stack.png" alt="Procmon kernel stack — annotated" /><br />
<em>Procmon call stack showing the transition from <code class="language-plaintext highlighter-rouge">ntdll.dll</code> in user mode into <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> and <code class="language-plaintext highlighter-rouge">FLTMGR.SYS</code> in kernel mode.</em></p>

<p>Here we see:</p>
<ul>
  <li><strong>ntdll.dll</strong> → last user-mode participant.</li>
  <li><strong>ntoskrnl.exe</strong> → the Windows kernel itself.</li>
  <li><strong>FLTMGR.SYS</strong> → the file system filter manager, routing file I/O through drivers (AV, encryption, backup tools).</li>
</ul>

<p>Even a trivial <code class="language-plaintext highlighter-rouge">CloseFile</code> operation passes through this layered chain.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Kernel rootkits often install themselves as <strong>filter drivers</strong>. By hijacking this chain, they can hide files, registry keys, or processes. Analysts must carefully inspect unexpected drivers in kernel stack traces.</p>
</blockquote>

<hr />

<h2 id="-step-4-putting-it-all-together">🔹 Step 4: Putting It All Together</h2>

<p>Here’s a simplified flowchart of the path a Notepad request takes — from user mode, through the syscall boundary, into kernel execution:</p>

<p>```mermaid
flowchart TD
    A[📝 Notepad.exe<br />(User Mode App)] –&gt; B[📚 kernel32.dll / KernelBase.dll<br />(Windows API)]
    B –&gt; C[📚 ntdll.dll<br />(Syscall Stub)]
    C –&gt; D[“⚡ syscall instruction<br />(User → Kernel Transition)”]
    D –&gt; E[🛠 ntoskrnl.exe<br />(Windows Kernel)]
    E –&gt; F[🔒 Drivers e.g., FLTMGR.SYS<br />(File System / AV / Filters)]
    F –&gt; G[💽 Hardware / Disk I/O]</p>



  <small>tags: <em></em></small>


      </section>
    </div>
  </body>
</html>
