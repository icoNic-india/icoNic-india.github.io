<h1 id="️-malware-series-1-from-notepad-to-the-kernel">🛡️ Malware Series #1: From Notepad to the Kernel</h1>
<h3 id="understanding-user-mode-vs-kernel-mode-in-windows">Understanding User Mode vs Kernel Mode in Windows</h3>

<p>When you open <strong>Notepad</strong>, it feels simple. But under the hood, even this basic Windows application walks a complex path from <strong>user mode to kernel mode</strong>.</p>

<p>Understanding that path is essential for malware analysts, because malicious software follows the same journey — and often tries to manipulate it.</p>

<p>In this article, we’ll use <strong>Process Monitor (Procmon)</strong> and <strong>WinDbg</strong> to trace Notepad’s behavior. Along the way, we’ll see how Windows transitions between user and kernel space, and why this matters in the world of malware analysis.</p>

<hr />

<h2 id="-step-1-process-startup--loading-the-foundations">🔹 Step 1: Process Startup — Loading the Foundations</h2>

<p>The first thing Procmon reveals is that when Notepad starts, it pulls in a familiar set of DLLs:</p>

<p><img src="/assets/images/notepad-dll-load.png" alt="Notepad DLL load — annotated" /><br />
<em>Procmon trace showing Notepad loading <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, and <code class="language-plaintext highlighter-rouge">KernelBase.dll</code>.</em></p>

<h3 id="-the-essential-dlls">🧩 The Essential DLLs</h3>
<ul>
  <li><strong>ntdll.dll</strong> → The last stop in user mode before entering the kernel. It contains system call stubs that eventually trigger the <code class="language-plaintext highlighter-rouge">syscall</code> instruction.</li>
  <li><strong>kernel32.dll</strong> → A higher-level wrapper exposing the Windows API developers use every day — memory, file I/O, threading.</li>
  <li><strong>KernelBase.dll</strong> → A core library that took over much of <code class="language-plaintext highlighter-rouge">kernel32.dll</code>’s responsibilities starting with Windows 7.</li>
</ul>

<p>Every Windows process — whether it’s Notepad or a sophisticated malware sample — relies on these libraries. They are the <em>foundations</em> of Windows user mode.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Attackers often <strong>hook or patch functions</strong> inside <code class="language-plaintext highlighter-rouge">kernel32.dll</code> or <code class="language-plaintext highlighter-rouge">KernelBase.dll</code> to intercept API calls. Since every process loads these DLLs, analysts should check them first for injected or tampered code.</p>
</blockquote>

<hr />

<h2 id="-step-2-the-system-call-transition">🔹 Step 2: The System Call Transition</h2>

<p>Once the DLLs are in place, Notepad doesn’t directly manipulate the kernel. Instead, its API calls flow into <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, which issues the actual <strong><code class="language-plaintext highlighter-rouge">syscall</code> instruction</strong>.</p>

<p><img src="/assets/images/syscall-transition.png" alt="Syscall boundary — annotated" /><br />
<em>WinDbg showing <code class="language-plaintext highlighter-rouge">NtCreateFile</code> ending with <code class="language-plaintext highlighter-rouge">syscall</code>, the CPU instruction that transitions execution from user mode to kernel mode.</em></p>

<p>At this precise point, execution leaves user space and enters kernel space:</p>
<ul>
  <li>The CPU switches context from <strong>Ring 3 (user mode)</strong> → <strong>Ring 0 (kernel mode)</strong>.</li>
  <li>The Windows kernel (<code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>) takes over to process the request.</li>
</ul>

<p>This invisible boundary is one of the most important in the OS. It defines <strong>privilege separation</strong>.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Many exploits target this syscall boundary. If malware can manipulate syscalls directly (bypassing user-mode APIs), it may <strong>evade EDR hooks</strong> that monitor high-level API calls.</p>
</blockquote>

<hr />

<h2 id="-step-3-kernel-execution--inside-the-os-core">🔹 Step 3: Kernel Execution — Inside the OS Core</h2>

<p>What happens once the syscall lands in kernel mode?<br />
Procmon’s stack traces show the journey clearly:</p>

<p><img src="/assets/images/procmon-kernel-stack.png" alt="Procmon kernel stack — annotated" /><br />
<em>Procmon call stack showing the transition from <code class="language-plaintext highlighter-rouge">ntdll.dll</code> in user mode into <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> and <code class="language-plaintext highlighter-rouge">FLTMGR.SYS</code> in kernel mode.</em></p>

<p>Here we see:</p>
<ul>
  <li><strong>ntdll.dll</strong> → last user-mode participant.</li>
  <li><strong>ntoskrnl.exe</strong> → the Windows kernel itself.</li>
  <li><strong>FLTMGR.SYS</strong> → the file system filter manager, routing file I/O through drivers (AV, encryption, backup tools).</li>
</ul>

<p>Even a trivial <code class="language-plaintext highlighter-rouge">CloseFile</code> operation passes through this layered chain.</p>

<blockquote>
  <p>💡 <strong>Malware Analyst’s Corner</strong><br />
Kernel rootkits often install themselves as <strong>filter drivers</strong>. By hijacking this chain, they can hide files, registry keys, or processes. Analysts must carefully inspect unexpected drivers in kernel stack traces.</p>
</blockquote>

<hr />

<h2 id="-step-4-putting-it-all-together">🔹 Step 4: Putting It All Together</h2>

<p>Here’s a simplified flowchart of the path a Notepad request takes — from user mode, through the syscall boundary, into kernel execution:</p>

<p>```mermaid
flowchart TD
    A[📝 Notepad.exe<br />(User Mode App)] –&gt; B[📚 kernel32.dll / KernelBase.dll<br />(Windows API)]
    B –&gt; C[📚 ntdll.dll<br />(Syscall Stub)]
    C –&gt; D[“⚡ syscall instruction<br />(User → Kernel Transition)”]
    D –&gt; E[🛠 ntoskrnl.exe<br />(Windows Kernel)]
    E –&gt; F[🔒 Drivers e.g., FLTMGR.SYS<br />(File System / AV / Filters)]
    F –&gt; G[💽 Hardware / Disk I/O]</p>
